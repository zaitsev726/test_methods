package org.nsu.fit.services.rest;

import com.github.javafaker.Faker;
import org.glassfish.jersey.client.ClientConfig;
import org.nsu.fit.services.log.Logger;
import org.nsu.fit.services.rest.data.*;
import org.nsu.fit.shared.JsonMapper;

import javax.ws.rs.client.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.util.*;
import java.util.stream.Collectors;

public class RestClient {
    // Note: change url if you want to use the docker compose.
//    private static final String REST_URI = "http://localhost:8080/tm-backend/rest";
    private static final String REST_URI = "http://localhost:8089/tm-backend/rest";

    private final static Client client = ClientBuilder.newClient(new ClientConfig().register(RestClientLogFilter.class));

    public AccountTokenPojo authenticate(String login, String pass) {
        CredentialsPojo credentialsPojo = new CredentialsPojo();

        credentialsPojo.login = login;
        credentialsPojo.pass = pass;

        return sendRequest(
                "authenticate",
                JsonMapper.toJson(credentialsPojo, true),
                AccountTokenPojo.class,
                null,
                MethodType.POST,
                null);
    }

    public CustomerPojo createAutoGeneratedCustomer(AccountTokenPojo accountToken) {
        ContactPojo contactPojo = new ContactPojo();
        Faker faker = new Faker();

        // Лабораторная 3: Добавить обработку генерацию фейковых имен, фамилий и логинов.
        // * Исследовать этот вопрос более детально, возможно прикрутить специальную библиотеку для генерации фейковых данных.
        contactPojo.firstName = faker.name().firstName();
        contactPojo.lastName = faker.name().lastName();
        contactPojo.login = faker.internet().emailAddress();
        contactPojo.pass = faker.internet().password(7, 11);

        return sendRequest(
                "customers",
                JsonMapper.toJson(contactPojo, true),
                CustomerPojo.class,
                accountToken,
                MethodType.POST,
                null);
    }

    public PlanPojo createPlanPojo(PlanPojo newPlanPojo, AccountTokenPojo accountToken) {
        return sendRequest(
                "plans",
                JsonMapper.toJson(newPlanPojo, true),
                PlanPojo.class,
                accountToken,
                MethodType.POST,
                null);
    }

    private enum MethodType {
        POST, GET, DELETE
    }

    private static <R> R sendRequest(
            String path,
            String body,
            Class<R> responseType,
            AccountTokenPojo accountToken,
            MethodType methodType,
            Map<String, Object> queryParams) {

        Logger.debug("Send post request to " + path);
        Logger.debug("Post request body: " + body);

        WebTarget prepared = client
                .target(REST_URI)
                .path(path);

        if (queryParams != null) {
            for (Map.Entry<String, Object> entry : queryParams.entrySet()) {
                prepared.queryParam(entry.getKey(), entry.getValue());
            }
        }

        Invocation.Builder request = prepared
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);


        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }

        Response response = Response.status(Response.Status.BAD_REQUEST).build();

        switch (methodType) {
            case POST:
                response = request.post(Entity.entity(body, MediaType.APPLICATION_JSON), Response.class);
                break;
            case DELETE:
                response = request.delete(Response.class);
                break;
            case GET:
                response = request.get(Response.class);
                break;
        }

        if (response.getStatus() != 200) {
            Logger.debug("Response status: " + response.getStatus() + " \nReason:" + response.getStatusInfo().getReasonPhrase());
            return null;
        }

        Logger.debug("Response status: " + response.getStatus());

        if (!response.hasEntity()) {
            Logger.debug("Empty entity");
            return null;
        }

        String responseBody = response.readEntity(String.class);
        Logger.debug("Response body: " + responseBody);
        return JsonMapper.fromJson(responseBody, responseType);
    }

    public void deletePlanPojo(PlanPojo planPojo, AccountTokenPojo adminToken) {
        sendRequest("plans/" + planPojo.id,
                "",
                void.class,
                adminToken,
                MethodType.DELETE,
                null);
    }

    public List<PlanPojo> getPlans(AccountTokenPojo adminToken) {
        Map<String, Object> queryParams = new HashMap<>();
        queryParams.put("customer_id", adminToken.id);

        return Arrays.stream(Objects.requireNonNull(sendRequest("plans",
                "",
                PlanPojo[].class,
                adminToken,
                MethodType.GET,
                queryParams))).collect(Collectors.toList());
    }

    public List<PlanPojo> getAvailablePlans(String login) {
        CredentialsPojo credentialsPojo = new CredentialsPojo();
        credentialsPojo.login = login;
        AccountTokenPojo customerToken = sendRequest(
                "authenticate",
                JsonMapper.toJson(credentialsPojo, true),
                AccountTokenPojo.class,
                null,
                MethodType.POST,
                null);

        return (Arrays.stream(Objects.requireNonNull(sendRequest(
                "available_plans",
                "",
                PlanPojo[].class,
                customerToken,
                MethodType.GET,
                null))).collect(Collectors.toList()));
    }

    public SubscriptionPojo createSubscriptionPojo(
            SubscriptionPojo newSubscriptionPojo,
            AccountTokenPojo customerToken) {

        return sendRequest(
                "subscriptions",
                JsonMapper.toJson(newSubscriptionPojo, true),
                SubscriptionPojo.class,
                customerToken,
                MethodType.POST,
                null);
    }

    public List<String> getSubscriptions(
            AccountTokenPojo adminToken,
            String customerId) {
        Map<String, Object> queryParams = new HashMap<>();
        queryParams.put("customer_id", customerId);

        return sendRequest(
                "subscriptions",
                "",
                List.class,
                adminToken,
                MethodType.GET,
                queryParams);
    }

    public List<String> getAvailableSubscriptions(AccountTokenPojo customerToken) {
        return sendRequest(
                "available_subscriptions",
                "",
                List.class,
                customerToken,
                MethodType.GET,
                null);
    }

    public void deleteSubscription(SubscriptionPojo subscriptionPojo,
                                   AccountTokenPojo customerToken) {
        sendRequest(
                "subscriptions/" + subscriptionPojo.id,
                "",
                void.class,
                customerToken,
                MethodType.DELETE,
                null);
    }

    public CustomerPojo createCustomer(CustomerPojo newCustomerPojo,
                                       AccountTokenPojo adminToken) {
        return sendRequest(
                "customers",
                JsonMapper.toJson(newCustomerPojo, true),
                CustomerPojo.class,
                adminToken,
                MethodType.POST,
                null);
    }

    public List<CustomerPojo> getCustomers(AccountTokenPojo adminToken,
                                           String customerLogin) {
        Map<String, Object> queryParams = new HashMap<>();
        queryParams.put("customerLogin", customerLogin);

        return Arrays.stream(Objects.requireNonNull(sendRequest(
                "customers",
                "",
                CustomerPojo[].class,
                adminToken,
                MethodType.GET,
                queryParams))).collect(Collectors.toList());
    }

    public void topUpCustomerBalance(AccountTokenPojo customerToken,
                                     TopUpBalancePojo topUpBalancePojo) {
        sendRequest(
                "customers/top_up_balance",
                JsonMapper.toJson(topUpBalancePojo, true),
                void.class,
                customerToken,
                MethodType.POST,
                null);
    }

    public void deleteCustomer(AccountTokenPojo adminToken,
                               CustomerPojo customerPojo) {

        sendRequest(
                "customers/" + customerPojo.id,
                "",
                void.class,
                adminToken,
                MethodType.DELETE,
                null);
    }

    public <R> R getMe(AccountTokenPojo adminToken, Class<R> responseType) {
        return sendRequest(
                "me",
                "",
                responseType,
                adminToken,
                MethodType.GET,
                null);
    }

    private static class RestClientLogFilter implements ClientRequestFilter {
        @Override
        public void filter(ClientRequestContext requestContext) {
            if (requestContext.hasEntity()) {
                Logger.debug(requestContext.getEntity().toString());
            }
            // Лабораторная 3: разобраться как работает данный фильтр
            // и добавить логирование METHOD и HEADERS.
            Logger.debug("Method name: " + requestContext.getMethod());
            Logger.debug("Header string: " + requestContext.getHeaders()
                    .keySet()
                    .stream()
                    .reduce("", (subtotal, element) -> subtotal + element + "|"));
        }
    }
}
